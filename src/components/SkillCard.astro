---
interface Props {
  title: string;
}

const { title } = Astro.props;
---

<div>
  <h2 class="sub-title text-white text-4xl mt-10 mb-10">{title}</h2>
  <div class="icons-container flex flex-wrap gap-5 w-full justify-center px-10">
    <slot />
  </div>
</div>

<style>
  h2.sub-title {
    font-family: "Royal Fight", serif;
    animation-timeline: view(50% 10%);
    animation-name: animate-sub-title;
    animation-fill-mode: both;
    animation-duration: 1ms;
  }
  @keyframes animate-sub-title {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
</style>

<script>
  import { observeElementInViewport } from "../scripts/isElementInViewPort";

  const skillsContainer = document.getElementById("skills-container");
  const iconsContainers = document.querySelectorAll(".icons-container");
  const allIcons = skillsContainer?.querySelectorAll("svg");

  const heartsContainers = document.querySelectorAll("span#hearts");
  const loveLevels = Array.from(heartsContainers)?.map(
    (currentHeartsContainer: any) =>
      parseInt(currentHeartsContainer?.getAttribute("data-love-level") || "0")
  );

  allIcons?.forEach((icon) => {
    icon.style.filter = "grayscale(100%)";
    icon.style.height = "50px";
  });
  function addHeartsOfLove(loveLevel: number, heartsContainer: any) {
    if (heartsContainer) {
      console.log("Animando corazón");
      heartsContainer.classList.remove("heart");
      void heartsContainer.offsetWidth; // Trigger reflow para reiniciar la animación. Obliga al navegador a recalcular el tamaño del elemento, void es para que no tome en cuenta el valor de offsetWidth, solo obliga al navegador a no pasar por alto el cambio de la clase por optimizar automaticamente la cosa...
      heartsContainer.classList.add("heart");

      // Asignar el contenido solo si no existe o si necesitas actualizar el contenido dinámico
      if (!heartsContainer.textContent) {
        heartsContainer.textContent = "❤️";
      }

      setTimeout(() => {
        heartsContainer.textContent = "";
      }, 1000);
    }
  }
  const onVisibilityChange = (result: any) => {
    if (result.isVisible) {
      iconsContainers?.forEach((iconsContainer, i) => {
        const thisIcons = iconsContainer.querySelectorAll("svg");

        // Coloring the icons
        if (i % 2 === 0) {
          for (let j = 0; j < thisIcons.length; j++) {
            setTimeout(() => {
              thisIcons[j].style.filter = "none";
            }, j * 300);
          }
        } else {
          for (let k = 0; k < thisIcons.length; k++) {
            setTimeout(() => {
              thisIcons[thisIcons.length - 1 - k].style.filter = "none";
            }, k * 300);
          }
        }
      });
      // Animation hearts
      console.log("Animando corazones");
      heartsContainers?.forEach((currentHeartsContainer: any, i: number) => {
        const currentLoveLevel = loveLevels[i];
        setTimeout(
          () => {
            addHeartsOfLove(currentLoveLevel, currentHeartsContainer);
          },
          2000 * Math.random() * 6
        );
      });
    } else {
      allIcons?.forEach((icon) => {
        icon.style.filter = "grayscale(100%)";
      });
    }
  };

  observeElementInViewport(
    skillsContainer as HTMLElement,
    onVisibilityChange,
    0.5
  );
</script>
